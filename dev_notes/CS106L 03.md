# CS 106L 03

## Survey results

- éœ‡æƒŠï¼è¿™é—¨è¯¾çš„æˆåˆ†å¤ªé«˜äº†ï¼PhD æœ‰ 40% å¤šğŸ˜‚

  ![image-20240415212124281](CS106L 03/image-20240415212124281.png)

## Overview of STL

- **"As mathematicians learned to lift theorems into their most general setting, so I wanted to lift algorithms and data structures."**
  																					â€”â€”Alex Stepanoy,inventor of the STL

  "Another benefit of striving for **efficiency** is that the process forces you to **understand the problem in more depth**."

  â€‹																					â€”â€”also Alex Stepanoy

- overview graph

  <img src="CS106L 03/image-20240415212624731.png" alt="image-20240415212624731" style="zoom: 50%;" />

## Sequence Containers

- **Provides access to sequences of elements**

  - `std::vector<T>`
  - `std::deque<T>`
  - `std::list<T>`
  - `std::array<T>`
  - `std::forward_list<T>`

  è¯¾ç¨‹åªä»‹ç»å‰ä¸¤ä¸ªï¼Œåé¢å‡ ä¸ªè¯·è‡ªæŸ¥

- `std::vector<T>`

  A vector represents **a sequence of elements of any type**

  you specify the type when using the vector

  ```c++
  std::vector<int> vecInt;
  std::vector<myStruct> vecStruct;
  std::vector<std::vector<string>> vecOfVec;
  ```

  highlight use:

  1. add k to the end of the vector: `v.push_back(k)`
  2. get the element at index i: `v.at(i) or v[i]`
  3. replace the element at index i: `v.at(i) = k or v[i] = k`

- why doesn't `std::vector` bounds check by default?

  By the philosophy of C++: if you write your program correctly, bounds checking will just slow your code down.

  ```c++
  vector<int> vecInt;
  vecInt.push_back(1);
  vecInt[2]; // this won't give an error!! causes undefined behavior
  vecInt.at(2) // throws an exception
  ```

- ä¸ºäº†è®© `push_front` å¾ˆå¿«ï¼ŒC++ stl ä½¿ç”¨äº† `std::deque` ä¹Ÿå°±æ˜¯ double ended queue åŒç«¯é˜Ÿåˆ—ï¼ŒCS106B ä¼šæ›´å¤šåœ°ä»‹ç»è¿™ä¸ªæ•°æ®ç»“æ„ï¼Œæœ‰æ—¶å€™è¿˜ä¼šå‡ºç°åœ¨è€ƒè¯•é‡ŒğŸ¤£

  ä½†æ˜¯ `deque` æ²¡æœ‰ `vector` åœ¨ access element  å¿«

- Takeaway: vector as default, deque if neccessary
- **Also, the next class is the most important class!!!**

## Associative Containers & Iterators

- CS106B å·²ç» half emptyğŸ˜†çœ‹æ¥å›½å†…å¤–éƒ½ä¸€æ ·

## Container Adaptors

- stack & queue å°±æ˜¯åœ¨ vector å’Œ deque ä¸Šæ„å»ºçš„ï¼Œå…¶å®å°±æ˜¯ vector or deque é™åˆ¶äº†ä¸€äº›åŠŸèƒ½

- stacks and queues are known as container adaptors

- Why not just use a vector/deque

  ä»ç„¶æ˜¯æ ¹æ® C++ philosophy

  - Epxress ideas and intent directly in code
  - Compartmentalize messy constructs

## Assignment 1

- ç®€å•ä»‹ç»äº†ä¸‹ assignment 1ï¼Œä¸è¦ç”¨ stanford library
- ä»£ç é‡ä¸ä¼šå¾ˆå¤§
- æœ‰ä¸€ä¸ª CourseReaderï¼Œå¤§æ¦‚æœ‰ 500 å¤š pagesï¼Œéå¸¸å…¨é¢çš„è¯¾ç¨‹ç¬”è®°ã€‚æœ‰ç©ºå¯ä»¥è¡¥å……ä¸‹è¯¾ç¨‹é‡Œæ²¡æœ‰ä»‹ç»çš„å†…å®¹

## Associative Containers

- data is accessed using key instead of indexes (map)

  - `std::map<T1, T2>`
  - `std::set<T>`
  - `std::unordered_map<T1, T2>`
  - `std::unordered_set<T>`

  ordered: based on ordering property of keys, keys need to be comparable (çœ‹æ¥ä¸æ˜¯å…ˆåé¡ºåº)

  unordered: based on hash function

  map/set: faster to iterate, based on red-black-tree

  unordered map/set: faster to access individual elements, based on hash table

## Iterators

- How do we iterate over associate containers?

  say NO to `for (int i = num; i < num; i++)`

  C++ has a solution! Iterator!

- **Iterators allow iteration over any container**

  we can get an iterator pointing to the "start" of the sequence by calling `mySet.begin()`

- type of iterator depends on the type you use

  ```c++
  set<int>::interator iter = mySet.begin();
  ```

- dereference

  We can get the value of an iterator by using the dereference * operator

- we can check if we have hit the end by comparing to `mySet.end()`

  ```c++
  if (iter == mySet.end()) return;
  ```

- å­¦ç”Ÿæé—®ï¼šiterator ä¸æ˜¯æŒ‡é’ˆï¼Ÿ

  iterator å’ŒæŒ‡é’ˆå¾ˆåƒï¼Œç”¨äº† 4 ä¸ªæŒ‡é’ˆæ¥å®ç°ï¼Œä½†åŠ©æ•™ä¹Ÿä¸æ˜ç™½ç»†å¾®åŒºåˆ«

  å­¦ç”Ÿæé—®ï¼šä¸ºä»€ä¹ˆä½¿ç”¨ `++iter` è€Œä¸æ˜¯ `iter++`

  prefix versus postfix operator

  `++iter` means increment before using the iterator

  `iter++` means use the iterator before increment

  åŒºåˆ«ä»…å­˜åœ¨äºå½“ `++iter or iter++` ä½œä¸ºå³å€¼æ—¶ï¼Œå‰è€… + 1 åè€…ä¸ + 1

  ```c++
  a = ++iter;
  ```

- ä½¿ç”¨ iterator çš„ä¸¤ç§æ–¹æ³•

  ```c++
  while (iter != container.end(){
      ...
      iter++;
  })
      
  for (iter = container.begin(); iter != container.end(); iter++){
      ...
  }
  ```

- ä¹‹å‰æœ‰ç”¨è¿‡æ›´å¥½ç”¨çš„å¾ªç¯æ–¹å¼

  ```c++
  for (auto& [key, value] : m){
      cout << key << " " << value << endl;
  }
  ```

  è¿™æ ·æ›´åŠ  python

## Map Iterators

- åŠ©æ•™çš„ vscode æ”¾äº† `word2vec.py`ï¼Œä»–ä¹Ÿæ˜¯ deep learning guy!!!

- å†æäº†ä¸€ä¸‹ `pair`

  a pair is simply two objects bundled together

  ```c++
  std::pair<string, int> p;
  p.first = "xxx";
  p.second = 1;
  ```

  a quicker way to make a pair

  ```c++
  std::make_pair("xxx", 1)
  ```

  this is great place to use auto

  ```c++
  auto time = std::make_pair(1, 45)
  ```

- Map iterators are slightly different, because we have both keys and values!  è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦å†æä¸€ä¸‹ pair

  dereference a map `map<string, int>`gives you a `std::pair<string, int>`

  ```c++
  map<int, int>::iterator i;
  cout << i->first;
  cout << (*i).first;
  ```

  è¿™é‡Œæåˆ°äº†ä¸€ä¸ª range-based for loopï¼Œæ˜¯ C++11 çš„ä¸€ä¸ªæ–°ç‰¹æ€§

  ```c++
  for(auto x: container){
      // codebase
  }
  ```

  ä½¿ç”¨ for çš„æ–¹æ³•ç®€å•äº†å¾ˆå¤šï¼Œå¯è¯»æ€§ä¹Ÿæ›´å¥½

  ç”šè‡³äºä½¿ç”¨ structured key val inside

  ```c++
  for(auto [key, val]: map){
      // codebase
  }
  ```

- è¿™é‡Œåˆæäº†ä¸€ä¸‹ parameter passing

  åœ¨ä¼ å…¥ä¸€ä¸ªå¤§çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚ä¸€ä¸ªæ•°ç»„ï¼Œä½ æ°¸è¿œæƒ³è¦ä½¿ç”¨ referenceï¼Œå¹¶ä¸”ä½ ä¸æ›´æ”¹å…¶ä¸­çš„å€¼ï¼Œæ‰€ä»¥è¦ä½¿ç”¨ constã€‚è¿™æ ·æ˜¯ä¸ºä»€ä¹ˆ `const Type& ` çš„å‚æ•°å½¢å¼ä¼šéå¸¸å¸¸è§

- æ¥ä¸‹æ¥ä¸¾ä¸¤ä¸ªä¾‹å­ï¼šsort element & find element

  ```c++
  // sorting a vector
  vector<int> vec{3,2,1,7,8};
  
  std::sort(vec.begin(), vec.end()); // might use custom function to compare
  // you can sort part of them
  std::sort(vec.begin(), vec.begin() + 1);
  
  printVec(vec);
  
  // finding an element
  set<int> elems{3,2,1,7,8};
  // you can use count
  elems.count(5);
  // you can also use find
  auto result_iter = std::find(elems.begin(), elems.end(), 5)
      
  if result_iter == elems.end(){
      cout << "Not Found" <<endl;
  }
  else{
      cout << "Found:" << *result_iter << endl;
  }
  ```

  `find` is slightly faster than `count`

  åœ¨è¿™é‡Œä¾‹å­é‡Œåˆä»‹ç»äº†ä¸¤ä¸ªå°æ–¹æ³• `lower_bound & upper_bound` 

  ```c++
  set<int>::iterator iter = elems.lower_bound(4) // find smallest element >= key
      
  set<int>::iterator end = elems.upper_bound(6) // find smallest elemetn > key
      
  // print element between them
      
  for (; iter != end; ++iter){
      cout << *iter << " ";
  }
  ```

  iterator ä¼šæ ¹æ® key çš„é¡ºåºè‡ªåŠ¨æ’åº

- Ranges

  we can iterate through different ranges

  <img src="CS106L 03/image-20240419230827976.png" alt="image-20240419230827976" style="zoom: 67%;" />

- æ­£å¼æå‡º range based `for` Loop, a shorthand 

  ```c++
  map<string, int> m;
  for(auto thing: m){
      // codebase
  }
  
  // equals
  
  for(auto iter=m.begin(); iter != m.end(); ++iter){
      auto thing = *iter;
      // codebase
  }
  ```

## Quick review of structs

- ç”±äºå»å¹´å¾ˆå¤šåŒå­¦åœ¨åšä½œä¸šçš„æ—¶å€™éƒ½è¢« struct è¯­æ³•éš¾åˆ°äº†ï¼Œæ‰€ä»¥æ‰“ç®—å¿«é€Ÿè®²ä¸€ä¸‹ struct

  ```c++
  // Declaring the struct definition
  struct Object{
   	type varl;
  	type var2;  
  }
  
  // Initializing a struct object using uniform initialization
  struct Object objName{value1, value2}
  // Operating on the struct object in this case,assigning a value
  objName.var1 = newvalue1;
  ```

  åœ¨ C++ ä¸­ always use `struct` before the struct type when use initalize a new struct object

  ä»¥ä½œä¸šä¸­çš„ä¾‹å­æ¥è®²è§£

  ```c++
  // How do you add a node to the graph
  
  struct SimpleGraph{
      vector<Node> nodes;
      vector<Edge> edges;
  }
  
  struct Node{
      double x;
      double y;
  }
  
  struct SimpleGraph graph{};
  
  graph.nodes.push_back({someXValue, someYValue}); // automatically creates Node object + adds to vector
  ```

- åœ¨è¿›è¡Œ Iterator  æ“ä½œæ—¶ä¼šæœ‰ä¸€äº›æ³¨æ„ç‚¹

  ä½¿ç”¨ linked list `std::list` æ—¶ä¸èƒ½ä½¿ç”¨ `iter + 3` è¿™ç§æ“ä½œï¼Œå› ä¸ºé“¾è¡¨ä¸èƒ½è·³è¿‡ä¸­é—´å…ƒç´ 

- Iterator Types

  <img src="CS106L 03/image-20240420105223228.png" alt="image-20240420105223228" style="zoom:67%;" />

  left arrow means it is a superset of previous type

  1. input

     read only, i.e. can only be dereferenced on the right side of expression

     ```c++
     int val = *iter;
     ```

     Use cases: `find & count`; input streams

  2. output

     write only, i.e. can only be dereferenced on the left side of expression

     ```c++
     *iter = 12;
     ```

     Use cases: copy; output streams

  3. forward

     combine input & ouput, + can make multiple passes

     è¿™é‡Œçš„ multiple passes è®²è§£å¾—ä¸æ˜¯å¾ˆæ¸…æ™°ï¼ŒåŠ©æ•™æ²¡åŠæ³•è§£é‡Šæ¸…æ¥š...æ‰€ä»¥éœ€è¦ä¸‹æ¥å†æŸ¥çœ‹ä¸‹ï¼Œä½†æ˜¯ä¹Ÿæåˆ°å¦‚æœä¸ç†è§£ä¹Ÿæ²¡å…³ç³»ï¼Œå®Œå…¨ä¸å½±å“

     åŠ©æ•™çš„ç†è§£ï¼šmultiple passes means, you can create multiple iterators to point to the same position, when you ++ for each of them , their position would also align. But this behavior is not guaranteed in input or output iterator

     åŠ©æ•™æåˆ° inheritence ä¼šæ¯”è¾ƒ tricky ä¼¼ä¹ä¸ä¼šåœ¨è¯¾ä¸Šè®²...ä¼šæä¾›é¢å¤–ææ–™

  4. bidirectional

     forward iterator, + can go backwards with decrement --

  5. random access

     can be increment or decrement by arbitrary amounts using + and -

  æœ€ååœ¨æäº†ä¸€ä¸‹ iterator å’Œ pointer çš„åŒºåˆ«ï¼Œå¤§æ„ï¼š

  - **Iterator**: æ˜¯ä¸€ç§æŠ½è±¡çš„æ¦‚å¿µï¼Œå®ƒæä¾›äº†ä¸€ç§è®¿é—®å®¹å™¨å…ƒç´ çš„æ–¹æ³•ï¼Œè€Œä¸å¿…æš´éœ²å®¹å™¨çš„å†…éƒ¨å®ç°ç»†èŠ‚ã€‚

  - **Pointer**: æ˜¯ä¸€ç§å…·ä½“çš„æ•°æ®ç±»å‹ï¼Œå®ƒå­˜å‚¨äº†å¦ä¸€ä¸ªå¯¹è±¡çš„å†…å­˜åœ°å€ã€‚æŒ‡é’ˆå…è®¸ç›´æ¥è®¿é—®å’Œæ“ä½œå†…å­˜ä¸­çš„æ•°æ®ã€‚

  ä¸ªäººç†è§£ï¼šiterator æä¾›äº†ä¸€ä¸ª pointer-like abstraction (interface)ï¼Œè®©å¤§å®¶æ›´å®‰å…¨è®¿é—®æ•°æ®
