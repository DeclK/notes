# Leetcode Hot 100

#### [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

这一题卡了我挺久的，很早就把状态方程给写出来了，但是在循环的时候不能很清晰地得到循环的方式...

现在理清思路过后总结一下，如何确保动态规划中能够得到正确的状态转移方程，并且获得遍历状态的方式得到最终结果：

1. 动态规划有时候像是一种抽象/复杂的分类讨论。当前状态是由过去状态转移得到，那么只要完整讨论了当前状态的所有可能状态就可以保证状态方程的正确性，也即当前状态 $x_t$ 是由哪些过去状态 $x_{t-i}$ 转移而来。有时候以当前状态的可能状态为出发点讨论是不太容易的，我们也可以从过去状态的可能状态为出发点进行讨论，也即过去状态 $x_{t-i}$ 将生成怎样的当前状态 $x_t$，只要过去状态的可能状态是完备的，我们也能得到正确的状态方程

2. 另一个难点在于状态循环，如果得到我们最终需要的答案。上一步是宏观上的递归思维，那么这一步我们就要回到微观的递归思维，也就是要彻底的递归，直到找到迭代的起点

   得到了状态转移方程后，我们就知道了当前的状态需要获得哪些过去状态完成转移，而我们只需要找到最少需要的过去状态，并且以此递归回去，就能够清晰的找到迭代路径了。说的太玄了，就拿这一题来距离吧

   ```python
   class Solution:
       def isMatch(self, s: str, p: str) -> bool:
           n = len(s)
           m = len(p)
           dp = [[False] * (m + 1) for _ in range(n + 1)]
           dp[0][0] = True
   
           def match(index_j, index_i):
               if p[index_j] == s[index_i]: return True
               if p[index_j] == '.': return True
   
           for i in range(n + 1):
               for j in range(1, m + 1):
                   index_i = i - 1
                   index_j = j - 1
                   if p[index_j] == '*':
                       if match(index_j - 1, index_i):
                           dp[i][j] = dp[i][j - 1] or dp[i][j - 2] or dp[i - 1][j]
                       else:
                           dp[i][j] = dp[i][j - 2]
                   else:
                       if match(index_j, index_i):
                           dp[i][j] = dp[i - 1][j - 1]
                       else:
                           dp[i][j] = False
           return dp[n][m]
   ```

   状态转移方程在代码中显示的很清楚，有多个子状态需要考虑。如果要得到 `dp[i][j]` 我们必然需要知道 `dp[i][j - 1], dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]` 这些状态的值。实际上我们只需要知道 `dp[i][j - 1]` 或者 `dp[i - 1][j]` 的值就可以了，为什么？以 `dp[i][j - 1]` 为例，当我们知道了它的状态后，根据递归的假设，我们也就知道了所有 `dp[0~i][0~j-1]` 的所有状态，其他的子状态也就不攻自破了。也就是说有一条迭代路径是从 0 开始一直迭代到 j 的。同理我们也可以得到另一条循环路径是从 0 迭代到 i 的。为了得到所有的状态，两条循环路径必须相互嵌套，这就能得到上面的代码了