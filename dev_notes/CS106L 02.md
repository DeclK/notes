# CS 106L 02

## String stream

- ç®€å•æ•™äº†ä¸€ä¸‹æ€ä¹ˆåˆ›å»º stringï¼Œç´¢å¼• stringï¼Œæ›´æ”¹ string

  ```c++
  string str = "Hello World";
  ```

- é¼“åŠ±ä½¿ç”¨ C++ strings è€Œä¸æ˜¯ C string

- Why streams

  we often want our programs to interact with external devices

  we need stream to do that

  - cout: streams to console

  - cin: streams from keyboard
  - streams to other programs
  - streams to files
  - ...

- å¦‚ä½•æŠŠ string é€åˆ° consoleï¼Ÿ

  é¦–å…ˆæŠŠ object è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åæŠŠå­—ç¬¦ä¸²é€åˆ° consoleã€‚ä¸‹åŠå¥è¯æ¯”è¾ƒéš¾ï¼Œè¿™å°±æ˜¯ stream è¦åšçš„äº‹æƒ…ï¼šæä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£æ¥å®Œæˆä¸å¤–éƒ¨è®¾å¤‡çš„äº¤äº’

  <img src="CS106L 02/image-20240410211833584.png" alt="image-20240410211833584" style="zoom:80%;" />

  æƒ³è±¡ stream æ˜¯ä¸€ä¸ª bufferï¼Œtreat it as a large array

  <img src="CS106L 02/image-20240410212246849.png" alt="image-20240410212246849" style="zoom:80%;" />

  **type conversion ç”±æ“ä½œç¬¦ operator  `<< & >>` æ ‡è¯†**

  stream çš„ä¸€å¤§å¥½å¤„ï¼Œä¼šè‡ªåŠ¨å¸®ä½ å¤„ç†å„ç§å„æ ·çš„ type conversionï¼Œå³ string å’Œå„ç§ type ä¹‹é—´çš„è½¬åŒ– 

- string stream

  string stream æ²¡æœ‰è¿æ¥åˆ°ä»»ä½•çš„å¤–éƒ¨è®¾å¤‡ï¼Œä½†æ˜¯å®ƒèƒ½å®Œæˆ type conversionï¼Œå¹¶ä¸”åˆ›å»ºäº†ä¸€ä¸ªå±äºè‡ªå·±çš„ bufferï¼Œè¿™ä¸ª buffer æ˜¯å¯ä»¥æ ¹æ®å†…å®¹æ‰©å®¹çš„<img src="CS106L 02/image-20240410214833877.png" alt="image-20240410214833877" style="zoom:80%;" />

  ```c++
  // string stream test
  #include <iostream>
  #include <sstream>
  
  int main() {
      std::ostringstream oss("long content");
      std::cout << oss.str() << std::endl;
      oss << "LONG"; // this would fill the "LONG" at the begining
      std::cout << oss.str() << std::endl;
      oss << " CONTENT";    // this would fill the string after the "LONG"
      oss.seekp(0);   // make the pointer at the front of the string
      oss << "SHORT"; // this would fill the "SHORT" at the begining
      std::cout << oss.str() << std::endl;
  }
  ```

  out stream & in stream æ˜¯å„è‡ªç‹¬ç«‹çš„ï¼Œæˆ‘ä»¬ä¸èƒ½å°† out stream buffer è½¬ç§»å›åˆ°ç¨‹åºå½“ä¸­ï¼Œå¾—ä½¿ç”¨ in stream æ‰èƒ½å®Œæˆè¿™æ ·çš„åŠŸèƒ½

  ```c++
  oss >> str; // error
  ```

  in stream ä¼¼ä¹ä¼šæ›´åŠ å¤æ‚ä¸€äº›ï¼Œå…¶éœ€è¦åˆ¤æ–­åº”è¯¥æµå…¥å¤šå°‘å†…å®¹

  ```c++
  // string stream test
  #include <iostream>
  #include <sstream>
  #include <string>
  int main() {
      std::istringstream iss("short 1 4.8");
      std::string str;
      int i;
      float f;
      iss >> str;     // only read the first word
      std::cout << str << std::endl;
      iss >> i;      // read the 1
      std::cout << i << std::endl;    
      iss >> i;      // read the 1
      std::cout << i << std::endl;
      iss >> f;      // read the .8, actually 0.8
      std::cout << f << std::endl;
  }
  ```

  è¿ç»­çš„ operator ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œ`<< & >>` ä¼šè¿”å› stream æœ¬èº«

  å¦ä¸€ä¸ªè§„åˆ™æ˜¯ï¼šstring stream å¿…é¡»åœ¨å·¦ä¾§ï¼Œå³ä¾§ä¸º valueã€‚ä¾‹å¦‚æˆ‘ä»¬æ— æ³•å°† value æ”¾åœ¨å·¦ä¾§ï¼Œç„¶åä½¿ç”¨ `>>` æµå…¥ cout or cin

  ```c++
  "test" >> std::cout;
  "test" << std::cin;
  ```

  å¯ä»¥ä½¿ç”¨ `.str` æ–¹æ³•æ¥æ›´æ–°é‡Œé¢çš„ buffer

  ```c++
  iss.str("buffer new");
  oss.str("buffer new");
  ```

- Learn more about string buffer

  it requires knowledge of pointers and C-arrays, learn more about them in CS107 è¿™é—¨è¯¾å¥½åƒæ˜¯æ•™è®¡ç®—æœºç»„æˆä¸ç³»ç»Ÿï¼Œåœ¨æŸ¥çœ‹ CS107 çš„è¿‡ç¨‹ä¸­å‘ç°äº† [zhihu](https://www.zhihu.com/tardis/zm/art/391911554?source_id=1005)ï¼ŒåŒ…å«äº†æ–¯å¦ç¦è®¡ç®—æœºä¸“ä¸šçš„æ ¸å¿ƒè¯¾ç¨‹åˆ—è¡¨

- when should I use a string stream
  - processing strings
  - formatting input output
  - parsing different types

## State bits

- 4 bits indicate the state of the stream
  1. good bitï¼Œnothing unsusual
  2. fail bitï¼Œtype mismatch
  3. end of buffer bit
  4. bad bitsï¼Œcan not move strings to buffer from external sourceã€‚åŸºæœ¬ä¸Šä¸å¤ªèƒ½ trigger è¿™ä¸ª

- read and write is expensive in programs

- `std::endl` will automatically flush the buffer in the stream immmediately, because it trigger the `std::flush`

  æ‰€ä»¥è¯´ `std::endl` = `"\n"` + `"std:flush"`

  `std::flush` is a manipulator

  > **Manipulators** are helping functions that can modify the [input/output](https://www.geeksforgeeks.org/basic-input-output-c/) stream. [link](https://www.geeksforgeeks.org/manipulators-in-c-with-examples/)

  ä¼¼ä¹ç°åœ¨ C++ çš„è§„åˆ™æ˜¯é‡åˆ° `\n` å°±ä¼šè‡ªåŠ¨ flushï¼Œè€Œæˆ‘åœ¨ windows ä¸‹é¢è·‘è¿™ä¸ªæ–‡ä»¶åªè¦ç”¨äº† cout å°±ä¼šè‡ªåŠ¨ flush

- why not use a string stream every where? why explicitly use in stream and out stream?

  å› ä¸º C++ æ˜¯ä¸€ä¸ªç²’åº¦å¾ˆç»†çš„è¯­è¨€ï¼Œæˆ‘ä»¬å¸Œæœ›æ˜ç¡®åœ°ä½¿ç”¨åˆ°åº•æ˜¯è¾“å…¥è¿˜æ˜¯è¾“å‡ºã€‚è¿™ä¹Ÿæ˜¯ä¹‹å‰æ‰€æåˆ°çš„ C++ philosophy

## io streams

- cin 

  - stuck the program if it is at eof bit state, and it asks for input messages

  - read something until it meets a white space or `\n`

  - `>>` will not include the whitespace, will skip it

    > the position pointer skip whitespace before the token with >> operation

  **why `>>` with cin is a nightmare!**

  1. ä¼šè¯»å–ä¸€æ•´è¡Œï¼Œä½†æ˜¯åœ¨ä½¿ç”¨ `>>` æå– token æ—¶ï¼Œåªä¼šä¸€ä¸ªä¸€ä¸ªæå–
  2. ç”±äº 1 çš„åŸå› ï¼Œæœªæå–çš„å­—ç¬¦ä¸²ä¼šç•™åœ¨ buffer é‡Œé¢
  3. å½“ä¸€ä¸ª cin failï¼Œæœªæ¥çš„ cin éƒ½ä¼š fail

  æ‰€ä»¥å¤§å®¶å–œæ¬¢ä½¿ç”¨ `getline` æ¥è·å¾—ä¸€æ•´è¡Œè¾“å…¥

  ```c++
  string name;
  getline(cin, name)
  ```

  å¹¶ä¸” `getline` do not skip the whitespace or the newline, although it does consume the newline, the the string won't include the newline `\n`

## modern C++ types

- warning would happen

  æ¯”è¾ƒä¸€ä¸ª signed int å’Œ unsigned int

  ```c++
  string str="a";
  for (int i = 0; i < str.size(); ++i)
  ```

  ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ä½¿ç”¨ä¸€ä¸ªç±»å‹ `size_t` æ¥ä»£è¡¨ unsigned int

  ```c++
  for (size_t i = 0; i < str.size(); ++i)
  ```

- **Type aliases** allow you give another name for a type

  `using map_iterator = std::unordered_map<forward_list<Student>, unordered_set>::const_iterator;`

  using è¿˜å¯ä»¥ç”¨äºå¯¼å…¥å‘½åç©ºé—´ï¼Œæˆ–è®¸ä¹‹åä¼šè®²åˆ°

- **auto**

  be careful about tricky auto gotchas! compiler ä¼šå¸®ä½ æ¨ç†å‡ºç±»åˆ«

  > **Gotcha** åœ¨[è®¡ç®—æœºç¼–ç¨‹](https://zh.wikipedia.org/wiki/è®¡ç®—æœºç¼–ç¨‹)é¢†åŸŸä¸­æ˜¯æŒ‡åœ¨ç³»ç»Ÿæˆ–[ç¨‹åº](https://zh.wikipedia.org/wiki/é›»è…¦ç¨‹å¼)ã€[ç¨‹åºè®¾è®¡è¯­è¨€](https://zh.wikipedia.org/wiki/ç¨‹åºè®¾è®¡è¯­è¨€)ä¸­ï¼Œåˆæ³•æœ‰æ•ˆï¼Œä½†æ˜¯ä¼šè¯¯è§£æ„æ€çš„æ„é€ 

  ```c++
  auto a = 2.4;						// double
  auto name = "Avery";				// C-string
  auto betterName = string{"Avery"};	// string
  ```

  auto ä¸ä¼šå¸®ä½ æ¨ç† const, reference&

  **auto can't be used in parameters, and don't use it unnecessarily for return types**

  **when to use auto**

  1. you don't care what the type is (iterators)
  2. the type is clear in the context (templates)
  3. you don't know what the type is (lambdas)

- **pair/tuple functions**

  ```c++
  using namespace std;
  auto prices = make_pair(3.4, 5); // pair<double, int>
  prices.first = prices.second; // {5.0, 5}
  
  auto values = make_tuple(3, 4, "hi"); // tuple<int, int, char*>
  get<0>(values) = get<1>(values);
  
  // structured binding (C++17) - extract each component
  auto [a, b] = prices;
  const auto& [x, y, z] = values;
  ```

  C++ 17 åæœ‰äº† unpack çš„æœºåˆ¶ (unbinding)

- struct functions

  ```c++
  struct Discount{ 
      double discountFactor;
      int expirationDate;
      std::string nameOfDiscount;
  }; // don't forget this semicolon :/
  auto discount = Discount{0.1, 20201231, "Christmas"};
  Discount discount2 = {0.2, 20201231, "Christmas"};
  // structured binding
  auto [factor, date, name] = discount;
  ```

  **A struct is a collection of named variables**

  To access a member, just use the `.` notation

  ä½¿ç”¨ pair ä½œä¸ºè¿”å›ï¼Œæœ‰ä¸€ä¸ªåå¤„ï¼Œå°±æ˜¯ä¸çŸ¥é“ pair çš„ç¬¬ä¸€ä¸ªå’Œå’Œç¬¬äºŒä¸ªçš„åŒºåˆ«ï¼ˆå½“äºŒè€…ç±»å‹ä¸€è‡´æ—¶ï¼‰ï¼Œç”¨ struct æ¥æ›¿ä»£ pair ä¼šæ›´å¥½

  ```c++
  struct PriceRange{
      int min;
      int max;
  };
  PriceRange findPriceRange(int dist){
      int min = static_cast<int>(dist * 0.08);
      int max = static_cast<int>(dist * 0.36);
      return PriceRange{min, max};
  }
  
  auto [min, max] = findPriceRange(dist);
  ```

- references

  åŠ©æ•™ä¸æƒ³è°ˆğŸ¤£ç›´æ¥è·³è¿‡

- Parameters and return values guidelines for modern C++

  - if it is input only use `func(const X&)`
  - if is is input and also return to the output use `func(X&)`
  - when it is cheap or impossible to copy, then you can use pass by value `func(X)` 

## Initialization

- **In C++, depending on the type, there were too many ways to initalize the variable**

  è®°ä½è¿™äº›ä¸œè¥¿æ˜¾ç„¶æ˜¯ä¸å¤ªå¯èƒ½çš„ï¼ˆä¸€å…±æœ‰27ç§ï¼‰ï¼

  To solve this, C++ (ironically) adds one more way: **uniform initialization**

  ```c++
  struct Course{
      string code;
      Time start, end;
      vector<string> instructors;
  }
  
  int main(){
      vector<int> vec{3, 1, 4, 1, 5, 9};
      Course now {"CS106l", {15, 30}, {"Wang", "Zhang"}}
      
      vector<int> vec1{3}; // vector = {3}
      vector<int> vec2(3); // vector = {0,0,0}
  }
  ```

  uniform ç»Ÿä¸€äº†ï¼šstruct, STL containers, class ç­‰æ‰€æœ‰å˜é‡çš„åˆå§‹åŒ–æ–¹å¼ã€‚åœ¨è¯ç”Ÿ uniform initialization ä¹‹å‰ï¼ŒSTL containers & struct ä½¿ç”¨çš„æ˜¯ `{}` è¿›è¡Œåˆå§‹åŒ–ï¼Œè€Œ class ä½¿ç”¨çš„æ˜¯ `()` è¿›è¡Œåˆå§‹åŒ–

## Question

- ä¼¼ä¹ stream æ˜¯ lecture 4ï¼Œè¿˜æœ‰ structures & references ä½œä¸º lecture 2 & lecture 3
