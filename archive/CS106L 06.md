# CS106L 06

## Classes from CS106B

- cs106B ä¼šä»‹ç»ä¸€äº›åŸºç¡€çš„é¢å‘å¯¹è±¡çŸ¥è¯† ep11 22:49

  åŒ…å« constructors & destructors & operator overloading & const

  åŠ©æ•™å†å‘é—®ï¼šwhat is the difference bewteen .h & .cpp

  ç®€å•æ¥è¯´ `.h` æœ‰ç‚¹åƒ api filesï¼Œè¿™äº› api èƒ½å¤Ÿè¢«å…¶ä»– classes ä½¿ç”¨ (declaration)ï¼Œè€Œ `.cpp` åˆ™æ˜¯æ‰€æœ‰çš„å®ç°ç»†èŠ‚ (implementation)

  <img src="CS106L 06/image-20240526201344172.png" alt="image-20240526201344172" style="zoom: 80%;" />

  ä½†ä½ ä¹Ÿå¯ä»¥åœ¨ `.h` ä¸­å®ç°ä¸€äº›å…·ä½“å‡½æ•°ï¼Œä½†è¿™äº›ä»£ç å°±æˆä¸ºäº† inline function

  é™¤äº† `.cpp` è¿˜æœ‰ä¸€äº›æ–‡ä»¶æ˜¯ä»¥ `.cc` ç»“å°¾çš„ï¼Œå®ƒä»¬åˆ°åº•æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼ŸåŠ©æ•™ç¬¬ä¸€æ¬¡çœ‹è¿™äº›åç¼€åä¹Ÿæ˜¯ä¸€è„¸æ‡µé€¼ğŸ˜±

  - Header files: `.h & .hh & .hpp`
  - Soure files: `.cc & .cpp & .cxx & .c++ & .C`

  IT turns out it depends on which compile you use!! ç®€å•æ€»ç»“ï¼š

  - Unix mostly use .cc, outside unix mostly use .cpp (windows)
  - .h is technically for C programs, if mixing C and C++ code, use .hh instead

  *If interested,see the third answer under: [stack overflow](https://stackoverflow.com/questions/1545080/c-code-file-extension-cc-vs-cpp/1545085)

- Constructor & Deconstructor, 25:42

  åœ¨ CS106L ä¸­ä¼šå®ç°æ¯” 106B æ›´å¤æ‚çš„ constructor, copy constructors, move constructors (in next weekğŸ˜)

  <img src="CS106L 06/image-20240526201610587.png" alt="image-20240526201610587" style="zoom:80%;" />

  deconstructor åœ¨è¯¾ç¨‹ä¸­ä¸ä¼šä»‹ç»å¤ªå¤š

  <img src="CS106L 06/image-20240526201728619.png" alt="image-20240526201728619" style="zoom:80%;" />

- Const keyword

  the const member function can't change the object's state, and so much more...

  <img src="CS106L 06/image-20240526201848716.png" alt="image-20240526201848716" style="zoom:80%;" />

- Operator overloading, will be covered in next lecture

  <img src="CS106L 06/image-20240526202148175.png" alt="image-20240526202148175" style="zoom:80%;" />

## Const

- Why const, 29:30

  For safety, generally

  Why not use global or non-const?

  Global can be read or modified by any part of the program, which is generally not safe

  åŠ©æ•™è¯´ä¸‹é¢çš„ä»£ç å¥¹èŠ±äº†ä¸‰ä¸ªå°æ—¶å» Debugï¼Œä¼¤é€äº†å¥¹çš„å¿ƒğŸ¤£

  <img src="CS106L 06/image-20240526211842965.png" alt="image-20240526211842965" style="zoom:50%;" />

  å¦‚æœä½¿ç”¨äº† const çš„è¯ã€‚ç¼–è¯‘å™¨ä¸€ä¸‹å­å°±èƒ½å‘ç°è¿™ä¸ªé”™è¯¯

- The const model,  35:00

  ```c++
  void f(const int& x) {
      aConstMethod(x);
      
      anotherConstMethod(x);
  }
  ```

  å¦‚æœ f è¦æ±‚ x ä¸èƒ½ä¿®æ”¹ï¼Œé‚£ä¹ˆæ˜¯å¦è¦æ±‚å­å‡½æ•° `aConstMethod & anotherConstMethod` ä¹Ÿåº”è¯¥æŒ‰ç…§ const ä¼ é€’ xï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼šæ‰€æœ‰ level çš„å‡½æ•°éƒ½åº”è¯¥æŒ‰ç…§ const æ¥æ¥æ”¶ x

  ä¸‹é¢çš„ä»£ç ä¹Ÿä¼šæŠ¥é”™ 40:00

  ```c++
  struct Planet {
      int countPolulation() const;
      void deathStar();
  }
  
  int Planet::countPopulation() const{
      return 42;
  }
  
  void Planet::deathStar() {
      cout << "BOOM" << endl;
  }
  
  void evil(const Planet& P) {
      // OK: countPopulation is const
      cout << p.countPolulation() <<end;
      // NOT OK: deathStar isn't const
      // calling a non-const function on a const parameter
      p.deathStar();
  }
  ```

  Everything must be const!!!

- A Const Pointer, very tricky 41:18

  ```c++
  // const pointer to a non-const int
  int*const p;
  
  (*p)++; // This is OK! changing the value
  p++; 	// This is not OK! changing the pointer
  ```

  æ­£ç¡®çš„é˜…è¯»æ–¹å‘ï¼š**right to th left!!!** you have a const pointer that points to a non-const int

  ```c++
  // non-const pointer to a const int
  // different syntax, but means the same
  const int* p;
  int const* p;
  
  // const pointer to const int
  const int* const p;
  int const* const p;
  ```

  const iterator works like const pointer, because iterator and pointer are similar concept

  ```c++
  const vector<int>::iterator iter = v.begin();
  
  ++iter; 	// This is NOT OK!
  *iter = 15; // This is OK!
  
  vector<int>::const_iterator iter = v.begin();
  
  *iter = 5;	// This is NOT OK!
  ++iter;		// This is OK!
  ```

  const can't apply to reference, because reference itself is inherently constant once they are bount to an object. so add  a const to a reference is not allowed

  ```c++
  void constPractice(const string& const x) {
      // This is not allowed
      // const string const& x, is also NOT allowed
      // BUT
      // string const& x is allowed whic is the same as const string& x
  }
  ```

- A challenge! 47:42

  ```c++
  const int* const myClassMethod(const int*const & param) const;
  ```

  å‘ç°ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ç†è§£æ–¹å¼ï¼šæŠŠ const å’Œ & ä½œä¸ºç±»å‹çš„ä¿®é¥°ï¼ˆä¸€ä¸ªä»£è¡¨é™åˆ¶èµ‹å€¼ï¼Œä¸€ä¸ªä»£è¡¨å¼•ç”¨æˆ–è€…å–å€ï¼‰ï¼ŒæŠŠ `*` ä½œä¸ºç±»å‹ï¼ˆä¹Ÿå°±æ˜¯è¯´æŠŠæŒ‡é’ˆä½œä¸ºä¸€ä¸ªå•ç‹¬çš„ç±»æ¥çœ‹å¾…ï¼‰

## Operator

- ç°åœ¨æ˜¯åŠ©æ•™å‘é›¶é£Ÿæ—¶é—´ğŸ˜€BTW åŠ©æ•™æ˜¯æ¥è‡ª Taiwanï¼è¿™èŠ‚è¯¾ä¼¼ä¹æ²¡æœ‰å¤ªå¤šçš„ä»£ç 

- ä¸€å…±æœ‰ 40 å¤šç§ operatorsï¼Œæ‰€ä»¥ä½ å¯ä»¥é‡è½½ 40 å¤šä¸ªç®—ç¬¦ï¼Œep12 11:27 

  <img src="CS106L 06/image-20240528232524263.png" alt="image-20240528232524263" style="zoom: 50%;" />

  æœ€å¤æ‚çš„æ˜¯ assignment operatorï¼Œä¹Ÿå°±æ˜¯ `=` operatorï¼Œè¿™å°†ä¼šåœ¨ä¸‹ä¸ª lecture ä»‹ç»

- How does C++ know how to apply operators to user-defined classes? 13:56

  ä¸‹é¢çœ‹ä»£ç 

  ```c++
  vector<string> v{"hello", "world"};
  cout << v[0];
  v[1] += "!";
  ```

  å®é™…ä¸Šä¸Šé¢çš„ä»£ç ç­‰ä»·äºï¼ŒC++ tries to call these functions

  ```c++
  vector<string> v{"hello", "world"};
  cout.operator<<(v.operator[](0));
  v.operator[](1).operator+=("!");
  ```

  or these ones

  ```c++
  vector<string> v{"hello", "world"};
  operator<<(cout, v.operator[](0));
  operator+=(v.operator[](1), "!");
  ```

  there are some operators yon can't use as non-member function like `v.operator[]()` can't use `operator[](v, )`

- Indeed, the people who wrote STL wrote these functions, 19:19

  ```c++
  ostream& operator<<(ostream&s, const string& val){
      ???
  }
  
  string& vector<string>::operator[](size_t index) const {
      ???
  }
  ```

  è¿™æ ·å°±èƒ½è§£é‡Šä¹‹é—´çš„ struct overload << çš„ä»£ç 

  ```c++
  struct Course {
      std::string name;
      int credits;
  
      // Overloading the stream insertion operator
      friend std::ostream& operator<<(std::ostream& os, const Course& course) {
          os << "Course Name: " << course.name << ", Credits: " << course.credits;
          return os;
      }
  };
  ```

- Let's try implement += operator to our vector<int>  class, 22:10

  we can also do it to a vector<string>ï¼Œè¿™é‡ŒåŠ©æ•™æé—®ï¼šä¸ºä»€ä¹ˆ C++ ä¸å®ç° vector<string> çš„ += ç®—ç¬¦é‡è½½ï¼Ÿæ²¡æœ‰å›ç­”

  what should the code look like?

  ```c++
  [some return type] StringVector::operator+=([some type] element) {
      push_back(element);
      return [something?];
  }
  ```

  what should the type of element be?

  the best is to use `const std::string&`, to make sure:1. not copy the parameter; 2. not moidfy the parameter

  the `const` is important especially when you pass a const into the parameter

  ```c++
  void TestConst(const int& x) {
      cout << x << endl;
  }
  
  void TestConst2(int& x) {
      cout << x << endl;
  }
  
  void TestConst3(int x){ 
  	cout << x << endl;
  }
  
  const int x = 2;
  TestConst(x);  // will work
  TestConst2(x); // will NOT WOKR! give error!
  TestConst3(x); // will work
  ```

  you can't pass a `const int x = 2` into the `TestConst2`, because `x` is const, it can not be bount to a non-const reference, otherwise it would violate the `const`-ness, potentially allowing modifications to the const value, which is not allowed!

  the `TestConst3` would directly copy the value of x, so it is irrelevant with the original const value

  the return value should also be the vector of strings by reference, so the return does not copy the value, too

  ```c++
  StringVector& StringVector::operator+=(const string& element) {
      push_back(element);
      return *this;
  }
  ```

  `this` is a pointer to the object itself!

  if you don't use reference the result might not be expected, 32:40

  ```c++
  StringVector vec;
  const string s = "Ito-en";
  (vec += s) += â€Green Teaâ€œ;
  ```

  now the vec would only have `"Ito-en"`, because return is a copy of the `vec` not the `vec` itself!

- implement a `+` operator, 40:23

  ```c++
  StringVector StringVector::operator+(const StringVector& other) const{
      StringVector result = *this; // copy constructor
      for (const std::string& s: other) {
          // result.push_back();
          result += s;
      }
      return result
  }
  ```

  ä¸‰ä¸ªæ³¨æ„ç‚¹ï¼š

  1. return type should not be reference, because we want to create a new one
  2. `StringVector result = *this` is a copy! è¿™å’Œ python å¾ˆä¸ä¸€æ ·å–”ï¼
  3. put a `const` at the member function, so we don't change the `this` potentially

  è¿˜å¯ä»¥ä½¿ç”¨ non member function

  ```c++
  StringVector operator+(const StringVector& first, const StringVector& second) {
      StringVector result = first;
      for (const std::string& s: second) {
          result += s
      }
      return result;
  }
  ```

- åŠ©æ•™åœ¨è¿™é‡Œæ‰“äº†ä¸ªå²”ï¼Œå…ˆå‡†å¤‡å®ç°ä¸€ä¸‹ `<<` ï¼ˆalligatorï¼‰çš„é‡è½½ï¼Œåªèƒ½ä½¿ç”¨ non-member functionï¼we can't overwrite the STL library, we have to use non member function!!!

  ```c++
  class Fraction {
      public:
      	Fraction();
      	Fraction(int num, int denom);
  	private:
      	int num;
      	int denom;
      	friend operator<<(ostream& os, const Fraction& f);
  }
  
  friend ostream& operator<<(std::ostream& os, const Function& f) {
      os << f.num << "/" << f.denom;
  }
  ```

  what is a `friend`?

  the function that is outside of your class, but can still have access to the class's variable

  why need a `friend`?

  If you have to implement an operator as a non-member, but need access to the private members.

- member v.s. non-member 51:51

  1. Some operators must be implemented as members eg.[]()->=due to C++semantics.

  2. Some must be implemented as non-members (eg.<< if you are writing class for rhs,not Ihs).
  3. If unary operator (eg.++) implement as member.
  4. & 5. omit here...

  è¯¢é—®äº† GPT è¯¥å¦‚ä½•å†³å®šä½¿ç”¨ member or non-member overload functionï¼ŒåŸºæœ¬éµå¾ªä»¥ä¸‹è§„åˆ™ï¼Œæˆ‘è§‰å¾—è¯´å¾—è¿˜æ˜¯æŒºåœ¨ç†çš„

  >**Member vs. Non-Member Function Rule of Thumb**
  >**If the operator changes the object on the left-hand side (like [], =, +=) or needs exclusive access to its internal state, it should be a member function.**
  >
  >**If the operator needs to work with two objects of different types (like <<, +, -) or doesn't need access to private members of either class, it should be a non-member function.**

- åŠ©æ•™ hate python çš„åŸå› ä¹‹ä¸€ï¼šambigous about the copy & deep copy haha, 1:00:14

  - Lecture 12: Next Lectures: All about copying... copy constructor, copy assignment
  - Lecture 13: More semantics: move contructor, move assignment

