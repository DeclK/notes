# CS106L 07

## Constructor & deconstructor

- A small example of const & constructor, when initializing some const members, you need to use initialize list, 14:00

  ```c++
  StringVector::StringVector():
  	// initialize list
  	logicalSize(0), allocatedSize(kInitialSize){
          // you can't do this when initializing const object
          // logicalSize = 0
          // allocatedSize = kInitialSize
          elems = new std::string[allocatedSize]
      }
  ```

  助教打了一个比喻，你可以在 declare const 变量时同时赋值，但是你不能在 declare const 变量之后再给它赋值

  ```c++
  const int a = 1;	// yes
  const int a;
  a = 1;				// no
  ```

  所以 initialize list 在初始化时对于 const 成员是必要的

  ```c++
  #include <iostream>
  class Test{
      // a constructor
      const int x;
      public:
      Test(int x): x(x){
          std::cout << "Constructor called" << std::endl;
          std::cout << x << std::endl;
      }
      // a destructor
      ~Test(){
          std::cout << "Destructor called" << std::endl;
      }
  };
  ```

## Copy operations

- Special member functions are (usually) automatically generated by the compiler 21:18

  - **Default construction**: object is created with no parameters
  - **Copy construction**:  object is created as a copy of an existing object
  - **Copy assignment**: existing object replaced as a copy of anther existing object
  - Destruction: object destroyed when it is out of scope

  助教打算详细讲解 copy 相关的 construction，这跟你使用 `=` 时会有关系

- Quick test, which special member function is called? 23:00

  ```c++
  StringVector function(StringVector vec0){	// copy constructor is called
      StringVector vec1;	//default constructor
      StringVector vecz2{"Ito","En","Green"};	// initializer constructor
      StringVector vec3(); // This declares a function!!! C++'s most vexing parse
      StringVector vec4(vec2); // copy constructor
      StringVector vec5{};	// default constructor
      StringVector vec6{vec3 + vec4};	// copy consturctor
      stringVector vec7 = vec4;	// copy constructor
      vec7 = vec2;	// copy assignment
  return vec7;	// copy constructor
  }
  ```

  call back: 之前提到了 `+=` operator does not work 28:00

  ```c++
  vector<int>operator+(const vector<int>&vec,int elem){
      vector<int> copy = vec; // copy constructor
      copy += element;
      return copy;	// copy constructor
  }
  ```

  当你没有实现 copy constructor 时，编译器会自动帮你实现简单的 copy constructor，而对于 `vec<int>` 来说，只会 copy 指向列表的指针 `int* elems`，而不会 copy 列表的内容。所以上面的代码在你的内存中将会存在三个 `vec<int>` (两份是 copy 出来的)

  <img src="CS106L 07/image-20240729140357816.png" alt="image-20240729140357816" style="zoom:80%;" />

  问题在当 `vec` 不在 scope 时，调用了 deconstructor，这会消除列表元素。而你再次调用 `copy` 的 deconstructor 时，会去消除一段已经消除的元素，这将会报错

  所以我们需要手动实现 copy constructor 保证所有的元素都被 copy

- Example of a copy assignment, 40:00

  ```c++
  StringVector&StringVector:operator=(const StringVector&other){
      // copy logicalsize,copy allocatedsize,make sure array length sare same
      // free the old vector
      // change elems to a new array of size allocatedsize
      // copy elems from other to this
      if (this == &other){
          return *this;
      }
      delete[]elems;
      allocatedsize other.allocatedsize;
      logicalsize other.logicalsize;
      elems new std:string[allocatedsize]
      std::copy(other.begin(), other.end(), begin());
      return *this;
  }
  ```

  quick question: why can't you use a initialize list to create a new one: because this is not a constructor!!!

- When do you need to write your special member functions? 47:28

  Ownership issues: a member is a handle on a resource outside of the class (e.g. pointes, filestreams)

  指针是一个很好的例子：object 拥有指针，但是不拥有指针中所包含的内容，所以我们需要实现自己的 copy constructor

  If you explicitly define or delete a copy constructor, or copy assignment, or deconstructor, you should define or delete all three. 也就是说定义了任意其中一个，最好把其他两个都写了

- 用一个简单的例子来引出下一次课的内容 `move`

  ```c++
  int main(){
  StringVector words;
  words = findAllWords("words.txt");
  // print words
  }
  StringVector finAllWords(const string&filename){
  	StringVector wrds;
  	//read from filename using an ifstream
  	return words;
  }
  ```

  在这个例子中我们只是想要读取 `words.txt` 中的内容，但是我们创建了三个 `words` StringVector，每一个都需要使用一个 copy constructor，这样就带来了资源浪费，我们能否通过只创建一个 StringVector 就获取到内容呢？Use `move` to steal the content!

## Move Semantics

- 介绍了 `emplace_back & push_back` 的区别 5:00

  push back 会创建对象的 copy，然后放到 vector 里面。但是 emplace back 不会创建对象的 copy，直接传入对象的参数，创建对象的过程直接在 vector 内部完成

  ```c++
  std::vector<People> elections;
  elections.emplace_back("Nelson Mandela", 1994);
  elections.emplace(Peopel("Franklin", 1936));
  ```

- 一个简单的 constructor 调用测试，提问：到底有多少 special function is called 15:00

  ```c++
  StrVector readNames(size_t size) {
      StrVector names(size, "Ito");
      return names;
  }
  
  int main () {
      StrVector name1 = readNames(16);
      StrVector name2;
      name2 = readNames(4);
  }
  ```

  answer, 7 constrctor, 6 deconstructor

  ```
  Hello from the fill constructor!
  Hello from the copy constructor!
  Hello from the destructor
  Hello from the copy constructor!
  Hello from the destructor
  Hello from the default constructor!
  Hello from the fill constructor!
  Hello from the copy constructor!
  Hello from the destructor
  Hello from the copy assignment operator!
  Hello from the destructor
  Hello from the destructor
  Hello from the destructor
  ```

  可以看到，上面虽然代码简单，但是有很多临时的对象被创建出来 `readNames(·)`，实际上我们不需要 `readNames` 一直创建对象，我们已经有了 `name1 or name2` 来承接其创建的内容。接下来我们就来优化这个事情

- lvalues & rvalues 25:00

  l-value is an expression that has a name (identity)

  - can find address using address-of operator (&)

  r-value is an expression that does not have a name (identity)

  - temporary values
  - can not find address using address-of operator (&)

  Examples of some left value and right value 34:23

  ```c++
  int val =2;
  int* ptr = 0x02248837;
  vector<int> v1{1, 2, 3};
  vector<int> v2{2, 3 ,4};
  
  auto& ptr2 = ptr;	// ptr2 is an l-value reference
  auto&& v4 = v1 + v2 // v4 is an r-value reference, && means r-value refernece
  auto& ptr3 = &val	// Error: can't bind l-value ref to r-value
  auto&& val2 = val; 	// Error: can't bind r-value ref to l-value
  
  const auto& ptr3 = ptr + 5; // OK: can bind const l-value ref to r-value, seems like auto&&, but auto&& can do a lot more!!
  ```

  似乎使用 `&&` 意义不大，在之后的 move / forwarding 会大显神威

  总结：r-value must be bound to l-value or r-value reference or const l-value reference

  question, difference of these expressions

  ```c++
  int val = 2;
  int* ptr = &val;   
  auto ptr1 = val;
  auto& prt3 = val;
  auto&& ptr4 = val;
  int&& ptr2 = 43;
  int&& ptr2 = val; // not allowed
  ```

- Why r-values are key to move semantics? 37:45

  - An object that is an l-value is NOT disposable, but an r-value is disposable, so you can steal an r-value resources

- 终于来到重点！Welcome the two new special member functions! 39:12

  - Move constructor (create new from existing **r-value)**
  - Move assignment (overwrite existing from existing **r-value)**

  注意下与 copy constructor 和 copy assignment 的区别

  - Copy constructor, create new from existing **l-value**
  - Copy assignment, overwrite existing from existing **l-value**

- Example

  it's really fast, using move, 因为减少了一半的 objects

  ```c++
  StrVector::StrVector(StrVector& other) noexcept:
  	elems(other.elems),
  	logicalSize(other.logicalSize),
  	allocatedSize(other.allocatedSize) {
          std::cout << "Hello from the copy constructor!" << std::endl;
          // other.elems = nullptr;
      }
   
  StrVector& StrVector::operator=(StrVector& rhs) noexcept {
      std::cout << "Hello from copy assignment" << std::endl;
      if (this != &rhs) {
          // remenber all `=` is a copy!!!
          delete[] elems; 
          logicalSize = rhs.logicalSize;
          allocatedSize = rhs.allocatedSize;
          elems = rhs.elems;
          // rhs.elems = nullptr;
      } 
  }
  
  // we can change the rhs to a r-value reference
  StrVector& StrVector::operator=(StrVector&& rhs) noexcept {
      std::cout << "Hello from copy assignment" << std::endl;
      if (this != &rhs) {
          // although rhs is a r-value reference, = is still a copy
          delete[] elems; 
          logicalSize = rhs.logicalSize;
          allocatedSize = rhs.allocatedSize;
          elems = rhs.elems;
          // rhs.elems = nullptr;
      } 
  }
  ```

  如何节省掉 copy？

  the solution: `std::move` unconditionally casts a variable cast to an r-value. Note: `move` itself does not actually move anything!!

  > From ChatGPT: **The `std::move` operation in C++ is a utility function that allows you to transfer ownership of resources from one object to another without copying them.** 

  ```c++
  StrVector& StrVector::operator=(StrVector&& rhs) noexcept {
      std::cout << "Hello from copy assignment" << std::endl;
      if (this != &rhs) {
          delete[] elems; 
          logicalSize = std::move(rhs.logicalSize);
          allocatedSize = std::move(rhs.allocatedSize);
          elems = std::move(rhs.elems);
          rhs.elems = nullptr;
      } 
  }
  ```

  个人理解：`std::move` 的出现，实际上就是重载了 `=` 算符，其本质只是一个标志。该标志告诉编译器，什么时候该去 copy 一个对象，而什么时候该去 move 一个对象，实际的实现才是核心的逻辑

- Task, write a swap function 51:24

  ```c++
  tempalte<typename T>
  void swap(T&a, T&b) {
      T temp = a ;
      a = b;
      b = temp;
  }
  ```

  这就是原始的 swap function 写法，但是每一行都使用了一个 copy，通过 move 可以解决

  ```c++
  tempalte<typename T>
  void swap(T&a, T&b) {
      T temp = std::move(a) ;
      a = std::move(b);
      b = std::move(temp);
  }
  ```

  但是这里面也没有提到使用 `auto&&` 这样的 r-value reference。根据上面的理解，这说明 `std::move` 确实只是一个标志性的东西，告诉 C++ 编译器去调用不同的函数

