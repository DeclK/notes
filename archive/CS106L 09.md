# CS106L 09

RAII and smart pointers

- how many code paths? ep17 4:00

  ```c++
  string EvaluateSalaryAndReturnName(Employee e )
      if (e.Title() == "CEO" || e.Salary()>100000 ) {
      cout << e.First() << " â€ 
      << e.Last() << "is overpaid" << endl;
      return e.First() + " " + e.Last();
  }
  ```

  There are at least 23 code paths in the code, ä¹‹æ‰€ä»¥æœ‰è¿™ä¹ˆå¤š code path æ˜¯å› ä¸ºè¦è€ƒè™‘ error æ‰€äº§ç”Ÿçš„ path

  å¼•å‡ºå¯èƒ½ä¼šäº§ç”Ÿ memory leak çš„å¯èƒ½

  ```c++
  string EvaluateSalaryAndReturnName(Employee e )
      Employee* em = new Employee
      if (e.Title() == "CEO" || e.Salary()>100000 ) {
      cout << e.First() << " â€ 
      << e.Last() << "is overpaid" << endl;
      delete em;
      return e.First() + " " + e.Last();
  }
  ```

  è¿™é‡Œçš„ `delete em` å¯èƒ½ä¸ä¼šè¢«æ‰§è¡Œï¼Œå› ä¸ºæœ‰å¯èƒ½åœ¨æ‰§è¡Œ `delete em` ä¹‹å‰å°±å‘ç”Ÿäº† errorï¼Œä»è€Œé€ æˆ memory leak

- More general concern: resources taht need to be released 15:00

  - Heap memory: `new` to aquire, `delete` to release
  - Files: `open` to aquire, `close` to release
  - Locks & Sockets: `try_lock & unlock`, `socket & close`

  ç±»ä¼¼äº python çš„ `with` è¯­å¥èƒ½å¦è§£å†³ï¼Ÿä½¿ç”¨ `__enter__ & __exit__` ä¸¤ä¸ªé­”æœ¯æ–¹æ³•

- Aside: Exceptions are a way to transfer control and information to a potential exception handler 18:12

  google do not use C++ exceptions, why? tldr: they forgot to do it initially, so let's not bother getting started. ğŸ˜‚

## RAII (Resource Acquisition Is Initialization)

- **How do we guarenteee classes release their resources?** use RAII

- RAII is really a bad name, another name is even worse **SBRM** (Scope Based Memory Management)ğŸ¤£ç”šè‡³è¿˜æœ‰ç¬¬ä¸‰ä¸ªåå­— **CADRE** (Constructor Acquires, Destructor Release)  23:00

- What is RAII? 26:45

  All resources should be acquired in the constructor.

  All resources should be released in the destructor.

  an example of not using RAII, might cause the compile to complain...

  ```c++
  void prinFile() {
      ifstream input();
      input.open("hamlet.txt");
      
      string line;
      while (getline(input, line)) {
          cout << line << endl;
      }
      input.close();
  }
  ```

  çœŸæ­£å¥½çš„æ–¹å¼åœ¨ constructor æœŸé—´å°±ç›´æ¥åˆ†é…å¥½èµ„æºï¼Œæ‰€ä»¥ä¹Ÿä¸éœ€è¦ä½¿ç”¨ close å»å…³é—­ï¼Œå› ä¸º ifstream ä¼šä½¿ç”¨ RAII è‡ªåŠ¨å…³é—­

  ```c++
  void prinFile() {
      ifstream input("hamlet.txt");
  
      string line;
      while (getline(input, line)) {
          cout << line << endl;
      }
      // no close needed!!
      // stream deconstructor releases access to file
  }
  ```

  ç¬‘æ­»ï¼ŒåŠ©æ•™è¯´ä»Šå¤©æœ‰ä¸€ä¸ªé¢è¯•ï¼Œé¢è¯•å®˜é—®ä»–ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ `lock_gard`ï¼ŒåŠ©æ•™ï¼šoh yeah, should I pull up my slides?ğŸ¤£

  so please, avoid calling `new` and `delete` explicitly, please use RAII

## Smart pointers

- C++ has built-in "smart" (i.e. RAII-compliant) pointers 39:00

  - `std::unique_ptr`

    **Uniquely owns its resource and deletes it when the object is destroyed. And it cannot be copied!** 41:00

    Reason why it cannot be copied: if you copy it, the resources would not be uniquely owned, it will be owned by 2 pointers, this is a problem when you free with one pointer, but the other still pointing to the resources.

    ```c++
    void rawPtrFn() {
        Node* n = new Node;
        delete n;
    }
    
    void SmartPtrFn() {
        std::unique_ptr<Node> n(new Node);
    }// Freed!
    ```

  - `std::shared_ptr`

    Resources can be stored by any number of shared_ptrs. Delete when none of them point to it. 43:00

    ```c++
    std::shared_ptr<int> p1(new int);
    // use p1
    std::shared_ptr<int> p2 = p1;
    // use p1 and p2
    ...
    // out of scope, freed !!
    ```

    è¿™ä¸ªæ¦‚å¿µå°±æœ‰ç‚¹åƒ python çš„åƒåœ¾å›æ”¶äº†

    Important: this copy only works, if new `shared_ptrs` are made though copying!

  - `std::weak_ptr`

    similar to `shared_ptr`, but used to with circular references of `shared_ptr`

- åŠ©æ•™ä¸‹å‘¨è¦å‡ºå·®äº†ï¼Œä½†ä»–æœ‰ä¸€ä¸ªå¿ƒæ„¿ï¼šå’Œè¯¾é‡Œçš„æ¯ä¸€ä¸ªäººæ‹ä¸€å¼ è‡ªæ‹ğŸ¤£

- **In modern C++, we pretty much never use `new` and `delete`!**

## Multithreading

- What is a thread? ep18 2:20 7:20

  - Code is usually sequential
  - Threads are ways to parallelise execution.

  åŠ©æ•™å«äº†ä¸¤ä¸ªäººï¼Œä¸¤ä¸ªäººçš„ä»»åŠ¡éƒ½æ˜¯åœ¨é»‘æ¿ä¸Šä»1å†™åˆ°10ï¼ŒåŠ©æ•™æ˜¯ controllerï¼Œå¥¹å«è°å¼€å§‹å†™ï¼Œè°å°±å¼€å§‹å†™ï¼Œå…¶ä¸­ä¸€ä¸ªäººåœ¨å†™çš„æ—¶å€™ï¼Œå¦ä¸€ä¸ªäººå¿…é¡»åœæ­¢

  right we have 2 threads, but only single controller

  ç°åœ¨æœ‰å¦å¤–ä¸€ä¸ªåœºæ™¯ï¼ŒåŠ©æ•™åˆå«äº†ä¸€ä¸ªäººä¸Šæ¥ï¼Œè¿™ä¸ªäººä½œä¸ºä¸€ä¸ªå¾ˆå·®çš„éšæœºæ•°ç”Ÿæˆå™¨ï¼Œéœ€è¦æ¯”è¾ƒé•¿çš„æ—¶é—´æ‰èƒ½ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ã€‚å…¶ä¸­ä¸€ä¸ªäººåœ¨å†™ 1åˆ°10 çš„æ—¶å€™ï¼Œå¿…é¡»è¦å…ˆä»è¿™ä¸ªäººè·å¾—éšæœºæ•°ï¼Œæ‰èƒ½ç»§ç»­å‘ä¸‹å†™ï¼Œè¿™æ ·ç­‰å¾…çš„æ—¶é—´å°†ä¼šéå¸¸ä¹…

  æ­¤æ—¶å¤šçº¿ç¨‹çš„ä¼˜åŠ¿å°±æ¥äº†ï¼š

  å½“åœ¨ç­‰å¾…éšæœºæ•°ç”Ÿæˆçš„æ—¶å€™ï¼Œå¦å¤–ä¸€ä¸ªçº¿ç¨‹å¯ä»¥ç»§ç»­è¿›è¡Œå·¥ä½œï¼Œä»è€Œæ©è—ç­‰å¾…æ—¶é—´ã€‚such waiting happens a lot, like: reading from file, waiting for response, cout string stream...

- Data race 12:06

  åœ¨è¿›è¡Œ multi-threading çš„æ—¶å€™éœ€è¦è€ƒè™‘ data raceï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œå…ˆåé¡ºåºä¼šå¯¼è‡´æ•°æ®çš„ä¸ç¡®å®šæ€§ï¼Œä»è€Œä½¿å¾—ç¨‹åºè¡¨ç°ä¸ä¸€è‡´

  <img src="CS106L 09/image-20240810163628717.png" alt="image-20240810163628717" style="zoom:50%;" />

- C++ multi-threading å¸¸ç”¨ headers 13:00

  - `atmoic` åŸå­æ“ä½œç±»
  - `mutex` lock guard
  - `condition_variable` å¯ç”¨äºçº¿ç¨‹ä¹‹é—´çš„é€šä¿¡
  - `future` å¼‚æ­¥æ“ä½œ

- Things to Take Away:

  - Use atomic types if doing multi-threading! ä½†æ˜¯åœ¨ CUDA é‡Œé¢åŸå­æ“ä½œæ˜¯éå¸¸è´¹æ—¶çš„

  - `std::lock_gard` vs `std::unique_lock`

  - 3 types of `locks`/mutexes: normal, timed, recursive

  - Condition varialbles allow cross-thread communication

    see CS110 for more

  - `std::async` is one way to use multi-threading

- Example 23:00

  ```c++
  #include <iostream>
  #include <vector>
  #include <mutex>
  #include <chrono>
  #include <thread>
  
  using std::cout; using std::endl; using std:string; using std::vector;
  
  void greet(int id) {    
      // std::this_thread::sleep_for(std::chrono::seconds(5));
      cout << "Hello there! My name is " << i << endl;
  }
  
  int main() {
      cout << "Greetings from my threads ... " << endl;
      std::thread thread1(greet, 1);
      std::thread thread2(greet, 2);
      cout << "All greettings are done" << endl;
      return 0;
  }
  ```

  å¦‚æœä½ è¿è¡Œä¸Šé¢çš„ç¨‹åºï¼Œä½ ä¼šå‘ç°è¾“å‡ºçš„ä¸œè¥¿ä¼šæ¯”è¾ƒä¹±ï¼Œå› ä¸ºä¸¤ä¸ª thread éƒ½åœ¨å‘ terminal è¿›è¡Œè¾“å‡ºã€‚ç”šè‡³ä½ çš„ `All greettings are done` éƒ½ä¼šæ¯” thread å…ˆè¾“å‡ºï¼ˆå¦‚æœ greet ç¨‹åºè¿è¡Œæ—¶é—´é•¿çš„è¯ï¼‰ã€‚è¿™æ˜¯å› ä¸º `main` ç¨‹åºæœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ª thread

  æ‰€ä»¥æˆ‘ä»¬è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š33:00

  1. è®©ä¸¤ä¸ªçº¿ç¨‹ä¸å†æ‰“æ¶
  2. ä¸è¦è®© main çº¿ç¨‹æå‰å®Œæˆï¼Œmain çº¿ç¨‹åº”å½“ç­‰å¾… thread1 & thread2 çº¿ç¨‹å®Œæˆè¿‡åå†ç»§ç»­æ‰§è¡Œ

  è§£å†³æ–¹æ¡ˆï¼š

  1. ä½¿ç”¨ `mutex & lock_guard` æ¥ä¿è¯ Only one thread can execute the code within the critical section at any given time

     ```c++
     std::mutex mtx; // Mutex declaration
     
     void greet(int id) {
         std::lock_guard<std::mutex> lock(mtx); // Lock the mutex
         cout << "Hello there! My name is " << id << endl; // Critical section
         // Mutex automatically unlocked when 'lock' goes out of scope
     }
     
     // equal usage but not RAII
     std::mutex mtx;
     
     void greet(int id) {
         mtx.lock(); // Manually lock the mutex
         cout << "Hello there! My name is " << id << endl;
         mtx.unlock(); // Manually unlock the mutex
     }
     
     ```

  2. using `thread.join` to tell the main thread to wait

     ```c++
     int main() {
         cout << "Greetings from my threads ... " << endl;
         std::thread thread1(greet, 1);
         std::thread thread2(greet, 2);
         thread1.join();
         thread2.join();
         cout << "All greettings are done" << endl;
     }
     ```

  é€šå¸¸ä¼šä½¿ç”¨ `vector<std::thread>` æ¥å®ç°å¤šä¸ª thread

  ```c++
  vector<std::thread> threads;
  
  for (size_t i=0; i < kNumThreads; ++i) {
      threads.push_back(std::thread(greet, i));
      // threads.emplace_back(greet, i);
      // threads[i].join();
  }
  
  for (std::thread& t: threads) {
      t.join();
  }
  ```

  æé—®ï¼šå¦‚æœä½¿ç”¨ `push_back` æ˜¯å¦ä¼š copy thread?

  GPT: When you use `push_back` with `std::thread`, you're adding an element to the vector by making a copy of the thread object. However, `std::thread` is not copyableâ€”it's movable. So, if you try to copy a `std::thread`, you'll get a compile-time error. Fortunately, `push_back` has an overload that accepts an rvalue reference (i.e., `std::move(thread)`), which allows you to move the `std::thread` into the vector.

  For `std::thread`, **both `push_back` and `emplace_back` are valid** as long as you use them correctly

## Where to Go

- è¿™å°±æ˜¯è¯¾ç¨‹çš„æœ€åä¸€èŠ‚è¯¾äº†ï¼å®Œç»“æ’’èŠ±ğŸ‰é‚£ä¹ˆå¦‚ä½•è¿›ä¸€æ­¥å­¦ä¹  C++ å‘¢ï¼ŸåŠ©æ•™ç»™äº†ä¸€äº› references

  <img src="CS106L 09/image-20240810175928324.png" alt="image-20240810175928324" style="zoom:50%;" />