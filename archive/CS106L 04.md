# CS106L 04

- æ€ä¹ˆè¿™ä¸€èŠ‚è¯¾æ˜¯æ‘„åƒæœºå½•åˆ¶ï¼Œä¸æ˜¯ç”µè„‘å½•åˆ¶ğŸ¤”è¿˜èƒ½å¬åˆ°ä¸­å›½äººåœ¨è¯´è¯ï¼Œåœ¨è®¨è®ºæ˜¥æ‹›ä»€ä¹ˆçš„ğŸ¤£

- Feedback of the course

  Likes: slides look nice, class is chill

  Dislikes: want more practice, want interactive lectures

- ä¸ºäº†ç»™è¯¾å ‚åŠ©å…´ï¼ŒåŠ©æ•™å¸¦äº† candyï¼Œæ¥çœ‹çœ‹ä»–ä¼˜é›…çš„å‘ç³–

  <img src="CS106L 04/image-20240420125527196.png" alt="image-20240420125527196" style="zoom: 50%;" />

- è¿™èŠ‚è¯¾å°±è¦å¼€å§‹å°† Templates äº†ï¼æ˜¯ generic program çš„ä¸€ç¯

- åŠ©æ•™é—®ï¼šprogramming æœ‰å“ªå‡ ç§èŒƒå¼ï¼Œå­¦ç”Ÿå›ç­”äº† object-oriented programmign & functional programming (å‡½æ•°å¼ç¼–ç¨‹)ï¼ŒåŠ©æ•™è¯´ C++ èƒ½åšå‡½æ•°å¼ç¼–ç¨‹ï¼Œä½†æ˜¯æœ‰æ›´é€‚åˆçš„è¯­è¨€ï¼ŒC++ æ›´é€‚åˆåšé¢å‘å¯¹è±¡ç¼–ç¨‹

  æœ€åå†è¡¥å……äº†ä¸€ä¸ª procedural programming ä¹Ÿå°±æ˜¯é¢å‘è¿‡ç¨‹ç¼–ç¨‹

  æœ€åå†æå‡º generic programming

## Template functions

- ä½¿ç”¨ `myMinMax`  æ¥ä½œä¸ºå¼•å­

  ```c++
  std::pair <int, int> myMinMax(int a, int b){
      return (a < b) ? std::make_pair(a, b) : std::make_pair(b, a);
  }
  
  std::pair<double, double> myMinMax(double a, double b){
      return (a < b) ? std::make_pair(a, b) : std::make_pair(b, a);
  }
  ```

  å¦‚æœæˆ‘ä»¬è¦è¿”å›çš„æ˜¯ `double` or `string` æ•°æ®ç±»å‹çš„ minmaxï¼Œåœ¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å†™å¾ˆå¤šä¸ªå‡½æ•°é€šè¿‡ C++ è‡ªèº«çš„é‡è½½å‡½æ•°åŠŸèƒ½ï¼ˆoverload functionsï¼‰å»å®Œæˆ

- æˆ‘ä»¬å…¶å®åªéœ€è¦æ”¹å˜ä¸Šé¢çš„ class type å°±è¡¨ç¤ºè¿™ä¸€ç±»å‡½æ•°

  ```c++
  std::pair<T, T> myMinMax(T a, T b){
      return (a < b) ? std::make_pair(a, b) : std::make_pair(b, a);
  }
  ```

  **we have a generic function!!!**

  but be sure to inform the compiler that T is a type

  ```c++
  template <typename T>
  std::pair<T, T> myMinMax(T a, T b){
      return (a < b) ? std::make_pair(a, b) : std::make_pair(b, a);
  }
  ```

  ä½†æ˜¯ä¸å»ºè®®ä½¿ç”¨ `T` ä½œä¸º Template typenameï¼Œå¯è¯»æ€§éå¸¸ä½

  `typename` ä¹Ÿæ˜¯ä¸€ä¸ªå¯ä»¥æ”¹å˜çš„éƒ¨åˆ†ï¼Œyou can change it to class

  ```c++
  template <class T>
  ```

  è¿™é‡Œå­¦ç”Ÿé—®äº†æŒºå¤šé—®é¢˜ï¼ˆæˆ‘å¬ä¸æ¸…æ¥šï¼‰ï¼Œä½†å¤§éƒ¨åˆ†çš„å›ç­”ï¼šwe will cover that in 20 miniutesğŸ˜

- Explicit instantiation: specify the type T

  ```c++
  auto [min3, max3] = myMinMax<std::string>("hello", "world");
  ```

  äº‹å®ä¸Šï¼Œæˆ‘ä»¬ä¼¼ä¹å¯ä»¥ä¸ä½¿ç”¨ explicit insantiationï¼ŒC++ ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„ type æ¥ç”Ÿæˆå‡½æ•°

  ```c++
  auto [min3, max3] = myMinMax("hello", "world")
  ```

  ä½†è¿™ä¸ªæ—¶å€™ä½ ä¼šè·å¾—ä¸€ä¸ªé”™è¯¯çš„ç­”æ¡ˆï¼Œå› ä¸º C++ ä¼šå°†å…¶è§†ä½œä¸€ä¸ª C-style stringï¼Œè€Œä¸æ˜¯ä¸€ä¸ª C++ string

  å¦‚æœä½¿ç”¨ uniform initializationï¼Œå°±å¿…é¡»ä½¿ç”¨ explicit instantiationï¼Œå› ä¸º uniform initialization ä¸æ¸…æ¥šä½¿ç”¨äº†å“ªä¸ªç±»å‹

  ```c++
  struct Point{
      int x, y;
  }
  
  struct Time{
      int hour, min;
  }
  
  getTypeValue({1, 2}, {3, 4})
  getTypeValue<Time>({1, 2}, {3, 4})
  ```

## Varadic Templates

(really cool, but the class will not cover itğŸ˜«)

## Concetp lifting

- æ¥ä¸‹æ¥å†™ä¸€ä¸ª `countOccurences` çš„å‡½æ•°ï¼ŒåŠ©æ•™ä½¿ç”¨æ¨¡æ¿è®©è¿™ä¸ªå‡½æ•°å˜å¾—è¶Šæ¥è¶Šä¸€èˆ¬åŒ–

  ```c++
  int countOccurances(const vector<int>& vec, int val){
      int count = 0;
      for (size_t i = 0; i < vec.size(); i++){
          if (vec[i] == val)
              count++;
      }
      return count;
  }
  
  // there is a assumption: vector type must be int
  // using template to make the function more general
  template <typename T>
  int countOccurances(const vector<T>& vec, T val){
      int count = 0;
      for (size_t i = 0; i < vec.size(); i++){
          if (vec[i] == val)
              count++;
      }
      return count;
  }
  
  // there is another assumption: it has to be a vector, but it can also be a map or a set
  // using template to make the function more general
  template <typename Container, typename T>
  int countOccurances(const Container& vec, T val){
      int count = 0;
      for (auto& elem : vec){
          if (elem == val)
              count++;
      }
      return count;
  
      // for (auto i = vec.begin(); i != vec.end(); i++){
      //     if (*i == val)
      //         count++;
      // }
  }
  
  // there is another assumption: it has to iterate through the container
  // passsing begin and end to the function
  template <typename Iterator, typename T>
  int countOccurances(Iterator begin, Iterator end, T val){
      int count = 0;
      for (auto i = begin; i != end; i++){
          if (*i == val)
              count++;
      }
      return count;
  }
  
  ```

## Implicit interfaces & concepts

- åˆæ‰“å¼€äº†æ–°çš„ä¸€è¯¾ï¼Œä¸Šæ¥å°±æœ‰äººé—®ï¼šhow do you compile a code using command line

  ```shell
  g++ -std=c++17 helloworld.cpp -o helloworld 
  ```

   æ•™äº†ä¸€ä¸‹ linux shell çš„ç®€å•ç”¨æ³•ï¼Œåˆ° 10 åˆ†é’Ÿæ‰è¿›å…¥æ­£é¢˜ï¼

- ä»Šå¤©çš„æ ¸å¿ƒ Solving the last Task:

  Count how many 5 appers in the second half of a list<string>

  Count how many elements in the second half of a  list<string> are at most 5

- More practice: what is the implicit interface?

  ä»€ä¹ˆæ˜¯ implicit interface? what requirement must be true about the collection

  ```c++
  template <typename Collection, typename DataType>
  int countOccurances(const Collection<DataType>& vec, DataType val){
      int count = 0;
      // for (auto& elem : list){
      //     if (elem == val)
      //         count++;
      // }
      // return count;
      for (size_t i=0; i < list.size(); i++){
          if (list[i] == val)
              count++;
      }
  }
  ```

  ä¸Šé¢è¿™æ®µä»£ç æ˜¯æœ‰é—®é¢˜çš„ï¼Œæœ‰ä¸€äº›éšè—çš„è¦æ±‚ï¼š

  1. Collection must be able to use index operation
  2. DataType must be comparable with item in Collection

  ä¸€ä¸ªè¯­æ³•é”™è¯¯ï¼šä½¿ç”¨äº† `Collection<DataType>`ï¼Œä½ ä¸èƒ½åœ¨å‡½æ•°çš„å‚æ•°é‡Œä½¿ç”¨ explicit instanciationï¼Œä¹Ÿå°±æ˜¯è¯´ä½ ä¸èƒ½ä¼ å…¥ template argument `DataType` ç»™åˆ° `Collection`ã€‚ä½ åº”è¯¥åœ¨çœŸæ­£ä¼ å…¥å‚æ•°çš„æ—¶å€™ç›´æ¥ä¼ å…¥æŸä¸ªç±»å‹

  ```c++
  vector<int> list;
  countOccurences(list, 1)
  ```

  it is normally unnecessary to use a template templateï¼Œé€šå¸¸æ¥è¯´ template of template åªæ˜¯èµ·ä¸€ä¸ª æ ‡è¯†ä½œç”¨ï¼Œç¡®ä¿ template ä½¿ç”¨çš„æ˜¯ template type

  ```c++
  // template template parameter
  template <typename T, template <typename> class Container>
  int countOccurancesT(const Container<T>& list, T val){
      int count = 0;
      for (auto& elem : list){
          if (elem == val)
              std::cout << "elem: " << elem << std::endl;
              std::cout << "val: " << val << std::endl;
              // count++;
      }
      return count;
  }
  
  
  std::vector<int> vec = {1, 2, 3};
  // you can't use vector<float> to the following function
  // because 3 is int
  result = countOccurancesT(vec, 3);
  ```

  ä»£ç è™½ç„¶èƒ½è·‘ï¼Œä½†æ˜¯ vscode ä¼šæ˜¾ç¤ºå¥‡æ€ªçš„è­¦å‘Š

  ```txt
  no instance of function template "countOccurancesT" matches the argument list
  ```

  ä½†æ—¢ç„¶ç¼–è¯‘èƒ½è¿‡ï¼Œé‚£å°±æ˜¯ vscode çš„é—®é¢˜ğŸ˜

  å›åˆ°ä¸»çº¿ï¼šè¿™äº› template å‡½æ•°å°†åŒ…å«ä¸€äº›éšè—è¦æ±‚ï¼Œå¹¶ä¸”åœ¨è¿è¡Œæ—¶çš„æŠ¥é”™ä¼šåˆè‡­åˆé•¿ï¼Œä½ æˆ–è®¸æ ¹æœ¬æ‰¾ä¸åˆ°é—®é¢˜æ‰€åœ¨ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒC++20 æ¨å‡ºäº†ä¸€ä¸ª `predicate` çš„æ¦‚å¿µï¼Œå®ƒèƒ½å¤Ÿç»™ template åšä¸€äº›é™åˆ¶å’Œè¦æ±‚ï¼Œä½¿å¾—é”™è¯¯èƒ½å¤Ÿç›´æ¥åœ¨ compile é˜¶æ®µç›´æ¥æš´éœ²ã€‚è¿™é‡Œä¸è¿‡å¤šå±•å¼€

## Function & lambda

- predicateï¼Œæ–­è¨€

  a predicate is a function which takes in some arguments and returns a boolean

  ```c++
  bool isDivisibleBy(int divided, int divisor){
      return divided % divisor == 0;
  }
  ```

- å›åˆ°æœ€å¼€å§‹æƒ³è¦è§£å†³çš„é—®é¢˜ï¼šhow many times does the element satisfy [predicate] in [a range of elements]

  ç°åœ¨å¯ä»¥ç”¨ predicate è§£å†³

  ```c++
  template<typename InputIterator, typename UniaryPredicate>
  int countOccurancesPredicate(InputIterator begin, InputIterator end, UniaryPredicate predicate) {
      int count = 0;
      for (auto i = begin; i != end; i++){
          if (predicate(*i))
              count++;
      }
      return count;
  }
  ```

  we can even make our predicate function a template

  ```c++
  template <typename DataType>
  inline bool lessThanTwo(DataType val) {return val < 2;}
  ```

- predicate çš„é—®é¢˜åœ¨å“ªé‡Œï¼Ÿ

  æˆ‘ä»¬å¸Œæœ›æ‰€å®ç°çš„ predicate å˜å¾—æ›´é€šç”¨ä¸€äº›ï¼Œä¸Šé¢æˆ‘ä»¬å®ç°äº† `lessThanTwo`ï¼Œé‚£ `lessThanFive & lessThanN` éƒ½è¦å®ç°ä¸€éå—ï¼Ÿ

  åŠ©æ•™æé—®ï¼šwhat is the implicit interface for predicate?

  å›ç­”ï¼špredicate only uses one paramete!

- what if the function needs information that not available at compile time? (e.g. user input)

  previous C++11 solutionï¼Œå†™ä¸€ä¸ªç±»ï¼Œå¹¶ä¸”æ„å»ºå…¶ `operator` æ–¹æ³•

  ```c++
  class GreaterThan {
      public:
      	GreaterThan(int limit) : limit(limit) {}
      	bool operator () (int val) {
              return val >= limit;
          }
      private:
      	int limit;
  }
  
  int limit;
  GreaterThan func(limit);
  countOccurance(iter.begin(), iter.end(), func)
  ```

  **C++11 solution: lambda functions!!!**

  ```c++
  auto func = [limit](auto val) {
      return val >= limit;
  }
  ```

  åŠ©æ•™è§£é‡Š lambda æ˜¯ä¸€ä¸ª lightweight objectï¼Œit's an object but act like function

  don't worry about the complex syntaxğŸ˜

  ```c++
  auto func = [capture_clause] (parameters) {
      //body
  }
  
  auto func = [capture_clause] (auto val) -> return-value {
      // body
  }
  // return-value is optional, if omitted then 'auto' is assumed
  ```

  c++ compiler å®é™…ä¸Šå°±æ˜¯æŒ‰ç…§ä¸Šé¢çš„ class æ„å»ºæ–¹å¼åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯ä½ ä¸çŸ¥é“è¿™ä¸ªå¯¹è±¡çš„åå­—ï¼ˆæ‰€ä»¥å«åŒ¿åå‡½æ•°ï¼‰

  capture valueï¼Œå°±æ˜¯æŠŠä¸€äº›å˜é‡é€åˆ° lambda function é‡Œé¢ï¼Œä½¿å¾— lambda function å¯ä»¥ä½¿ç”¨

  capture by reference or capture by value

  ä¸‹é¢æ˜¯ lazy ways of capturing variables, not recommended

  ```c++
  // capture all by value, except teas is by reference
  auto func1 = [=, &teas] (params){}
  // capture all by reference, except banned is by value
  auto func2 = [&, banned] (params)
  ```

  
